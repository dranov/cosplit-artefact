{"version": 1, "nonce": 1, "toAddr": "0x0000000000000000000000000000000000000000", "amount": "0", "pubKey": "021e269b1a1509b417cd97795176235d948af40cbcf9ac1393aa02caa5e86c5177", "gasPrice": "100", "gasLimit": "10000", "code": "scilla_version 0\n\n(* This contract implements a fungible token interface a la ERC20.*)\n\n(***************************************************)\n(*               Associated library                *)\n(***************************************************)\nlibrary FungibleToken\n\nlet min_int =\n  fun (a : Uint128) => fun (b : Uint128) =>\n  let alt = builtin lt a b in\n  match alt with\n  | True =>\n    a\n  | False =>\n    b\n  end\n\nlet le_int =\n  fun (a : Uint128) => fun (b : Uint128) =>\n    let x = builtin lt a b in\n    match x with\n    | True => True\n    | False =>\n      let y = builtin eq a b in\n      match y with\n      | True => True\n      | False => False\n      end\n    end\n    \n\n(***************************************************)\n(*             The contract definition             *)\n(***************************************************)\n\ncontract FungibleToken\n(owner : ByStr20,\n total_tokens : Uint128,\n decimals : Uint32,\n name : String,\n symbol : String)\n\n(* Initial balance is not stated explicitly: it's initialized when creating the contract. *)\n\n(* ANNOTATE: @own([address][$]) if shard_of(address) == shard_of(_sender) *)\nfield balances : Map ByStr20 Uint128 =\n  let m = Emp ByStr20 Uint128 in\n    builtin put m owner total_tokens\n(* ANNOTATE: @own([address][$]) if shard_of(address) == shard_of(_sender) *)\nfield allowed : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)\n\n(* Have to decide whether to shard this or not. Either choice is valid. *)\ntransition BalanceOf (tokenOwner : ByStr20)\n  bal <- balances[tokenOwner];\n  match bal with\n  | Some v =>\n\te = {_eventname : \"BalanceOf\"; address : tokenOwner; balance : v};\n\tevent e\n  | None =>\n\te = {_eventname : \"BalanceOf\"; address : tokenOwner; balance : Uint128 0};\n    event e\n  end\nend\n\ntransition TotalSupply ()\n  e = {_eventname : \"TotalSupply\"; caller : _sender; balance : total_tokens};\n  event e\nend\n\n(* INFER: can be processed in _sender shard *)\ntransition Transfer (to : ByStr20, tokens : Uint128)\n  bal <- balances[_sender];\n  match bal with\n  | Some b =>\n    can_do = le_int tokens b;\n    match can_do with\n    | True =>\n      (* subtract tokens from _sender and add it to \"to\" *)\n      new_sender_bal = builtin sub b tokens;\n      balances[_sender] := new_sender_bal;\n\n      (* INFER: Need to detect this as a comutative operation *)\n      (* Adds tokens to \"to\" address *)\n      to_bal <- balances[to];\n      new_to_bal = match to_bal with\n      | Some x => builtin add x tokens\n      | None => tokens\n      end;\n\n  \t  balances[to] := new_to_bal;\n      e = {_eventname : \"TransferSuccess\"; sender : _sender; recipient : to; amount : tokens};\n      event e\n    | False =>\n      (* balance not sufficient. *)\n      e = {_eventname : \"TransferFailure\"; sender : _sender; recipient : to; amount : Uint128 0};\n      event e\n    end\n  | None =>\n    (* no balance record, can't transfer *)\n  \te = {_eventname : \"TransferFailure\"; sender : _sender; recipient : to; amount : Uint128 0};\n    event e\n  end\nend\n\n(* INFER: can be processed in from shard, i.e. if shard_of(_sender) == shard_of(from) *)\ntransition TransferFrom (from : ByStr20, to : ByStr20, tokens : Uint128)\n  bal <- balances[from];\n  (* Check if _sender has been authorized by \"from\" *)\n  sender_allowed_from <- allowed[from][_sender];\n  match bal with\n  | Some a =>\n    match sender_allowed_from with\n    | Some b =>\n        (* We can only transfer the minimum of available or authorized tokens *)\n        t = min_int a b;\n        can_do = le_int tokens t;\n        match can_do with\n        | True =>\n            (* tokens is what we should subtract from \"from\" and add to \"to\" *)\n            new_from_bal = builtin sub a tokens;\n            balances[from] := new_from_bal;\n            (* INFER: Need to detect this as a comutative operation *)\n            to_bal <- balances[to];\n            match to_bal with\n            | Some tb =>\n                new_to_bal = builtin add tb tokens;\n                balances[to] := new_to_bal\n            | None =>\n                (* \"to\" has no balance. So just set it to tokens *)\n                balances[to] := tokens\n            end;\n            (* reduce \"allowed\" by \"tokens\" *)\n            new_allowed = builtin sub b tokens;\n            allowed[from][_sender] := new_allowed;\n            e = {_eventname : \"TransferFromSuccess\"; sender : from; recipient : to; amount : tokens};\n            event e\n        | False =>\n            e = {_eventname : \"TransferFromFailure\"; sender : from; recipient : to; amount : Uint128 0};\n            event e\n        end\n    | None =>\n        e = {_eventname : \"TransferFromFailure\"; sender : from; recipient : to; amount : Uint128 0};\n        event e\n    end\n  | None =>\n\te = {_eventname : \"TransferFromFailure\"; sender : from; recipient : to; amount : Uint128 0};\n\tevent e\n  end\nend\n\n(* INFER: can be processed in _sender shard *)\ntransition Approve (spender : ByStr20, tokens : Uint128)\n  allowed[_sender][spender] := tokens;\n  e = {_eventname : \"ApproveSuccess\"; approver : _sender; spender : spender; amount : tokens};\n  event e\nend\n\n(* INFER: can be processed in tokenOwner shard, i.e. if shard_of(_sender) == shard_of(tokenOwner) *)\ntransition Allowance (tokenOwner : ByStr20, spender : ByStr20)\n  spender_allowance <- allowed[tokenOwner][spender];\n  match spender_allowance with\n  | Some n =>\n      e = {_eventname : \"Allowance\"; owner : tokenOwner; spender : spender; amount : n};\n      event e\n  | None =>\n      e = {_eventname : \"Allowance\"; owner : tokenOwner; spender : spender; amount : Uint128 0};\n      event e\n  end\nend\n", "data": "[{\"vname\": \"_scilla_version\", \"type\": \"Uint32\", \"value\": \"0\"}, {\"vname\": \"owner\", \"type\": \"ByStr20\", \"value\": \"0x1c2c7516dac2140c47cbae264e8349bb7c07a534\"}, {\"vname\": \"_sharding_input\", \"type\": \"String\", \"value\": \"{\\\"transitions\\\" : [\\\"Transfer\\\", \\\"TransferFrom\\\", \\\"Mint\\\"], \\\"weak_reads\\\": [\\\"Transfer:balances[_sender]\\\", \\\"TransferFrom:balances[from]\\\"]}\"}, {\"vname\": \"total_tokens\", \"type\": \"Uint128\", \"value\": \"1000000000000000000000000000000000\"}, {\"vname\": \"decimals\", \"type\": \"Uint32\", \"value\": \"0\"}, {\"vname\": \"name\", \"type\": \"String\", \"value\": \"Megabux\"}, {\"vname\": \"symbol\", \"type\": \"String\", \"value\": \"MGBX\"}]", "signature": "29c960089d48b5d9d953ac58d0c6ba3d22908eb2784380ea1ea2c7e376665f0985690732567d257dc50431a44bb912444cc28ba08c10c81bd72398f4c1313ad3", "priority": false}
{"version": 1, "nonce": 25, "toAddr": "0x0000000000000000000000000000000000000000", "amount": "0", "pubKey": "021e269b1a1509b417cd97795176235d948af40cbcf9ac1393aa02caa5e86c5177", "gasPrice": "100", "gasLimit": "20000", "code": "(***************************************************)\n(*                 Scilla version                  *)\n(***************************************************)\n\nscilla_version 0\n\n(***************************************************)\n(*               Associated library                *)\n(***************************************************)\nimport BoolUtils\n\nlibrary Crowdfunding\n\nlet one_msg = \n  fun (msg : Message) => \n    let nil_msg = Nil {Message} in\n    Cons {Message} msg nil_msg\n\nlet blk_leq =\n  fun (blk1 : BNum) =>\n  fun (blk2 : BNum) =>\n    let bc1 = builtin blt blk1 blk2 in \n    let bc2 = builtin eq blk1 blk2 in \n    orb bc1 bc2\n\nlet get_funds_allowed =\n  fun (cur_block : BNum) =>\n  fun (max_block : BNum) =>\n  fun (balance : Uint128) =>\n  fun (goal : Uint128) =>\n    let in_time = blk_leq cur_block max_block in\n    let deadline_passed = negb in_time in\n    let target_not_reached = builtin lt balance goal in\n    let target_reached = negb target_not_reached in\n    andb deadline_passed target_reached\n\nlet claimback_allowed =\n  fun (balance : Uint128) =>\n  fun (goal : Uint128) =>\n  fun (already_funded : Bool) =>\n    let target_not_reached = builtin lt balance goal in\n    let not_already_funded = negb already_funded in\n    andb target_not_reached not_already_funded\n\nlet accepted_code = Int32 1\nlet missed_deadline_code = Int32 2\nlet already_backed_code  = Int32 3\nlet not_owner_code  = Int32 4\nlet too_early_code  = Int32 5\nlet got_funds_code  = Int32 6\nlet cannot_get_funds  = Int32 7\nlet cannot_reclaim_code = Int32 8\nlet reclaimed_code = Int32 9\n\n(***************************************************)\n(*             The contract definition             *)\n(***************************************************)\ncontract Crowdfunding\n\n(*  Parameters *)\n(owner     : ByStr20,\nmax_block : BNum,\ngoal      : Uint128)\n\n(* Mutable fields *)\n(* ANNOTATE: @own([backer][$]) if backer == _sender  *)\nfield backers : Map ByStr20 Uint128 = Emp ByStr20 Uint128\nfield funded : Bool = False\n\nprocedure DonationEvent (failure : Bool, error_code : Int32)\n  match failure with\n  | False =>\n    e = {_eventname : \"DonationSuccess\"; donor : _sender;\n         amount : _amount; code : accepted_code};\n    event e\n  | True =>\n    e = {_eventname : \"DonationFailure\"; donor : _sender;\n         amount : _amount; code : error_code};\n    event e\n  end\nend\n\nprocedure PerformDonate ()\n  c <- exists backers[_sender];\n  match c with\n  | False =>\n    accept;\n    backers[_sender] := _amount;\n    DonationEvent c accepted_code\n  | True =>\n    DonationEvent c already_backed_code\n  end\nend\n\n(* INFER: exclusive ownership, can shard to _sender's shard *)\ntransition Donate ()\n  blk <- & BLOCKNUMBER;\n  in_time = blk_leq blk max_block;\n  match in_time with \n  | True  => \n    PerformDonate\n  | False =>\n    t = True;\n    DonationEvent t missed_deadline_code\n  end \nend\n\nprocedure GetFundsFailure (error_code : Int32)\n  e = {_eventname : \"GetFundsFailure\"; caller : _sender;\n       amount : _amount; code : error_code};\n  event e\nend\n\nprocedure PerformGetFunds ()\n  bal <- _balance;\n  tt = True;\n  funded := tt;\n  msg = {_tag : \"\"; _recipient : owner; _amount : bal; code : got_funds_code};\n  msgs = one_msg msg;\n  send msgs\nend\n  \n(* Is it realistic to expect this can be inferred to be shardable? *)\n(* There is only one accepted _sender (i.e. owner), so no *)\n(*  double-spends are possible when sharding to _sender shard. *)\ntransition GetFunds ()\n  is_owner = builtin eq owner _sender;\n  match is_owner with\n  | False =>\n    GetFundsFailure not_owner_code\n  | True => \n    blk <- & BLOCKNUMBER;\n    bal <- _balance;\n    allowed = get_funds_allowed blk max_block bal goal;\n    match allowed with \n    | False =>  \n      GetFundsFailure cannot_get_funds\n    | True =>\n      PerformGetFunds\n    end\n  end   \nend\n\nprocedure ClaimBackFailure (error_code : Int32)\n  e = {_eventname : \"ClaimBackFailure\"; caller : _sender;\n       amount : _amount; code : error_code};\n  event e\nend\n\nprocedure PerformClaimBack (amount : Uint128)\n  delete backers[_sender];\n  msg = {_tag : \"\"; _recipient : _sender; _amount : amount; code : reclaimed_code};\n  msgs = one_msg msg;\n  e = { _eventname : \"ClaimBackSuccess\"; caller : _sender; amount : amount; code : reclaimed_code};\n  event e;\n  send msgs\nend\n\n(* Similar question to above: is it realistic to infer anything here? *)\n(* This depends on the invariant that sum(backers) = _balance *)\ntransition ClaimBack ()\n  blk <- & BLOCKNUMBER;\n  after_deadline = builtin blt max_block blk;\n  match after_deadline with\n  | False =>\n    ClaimBackFailure too_early_code\n  | True =>\n    bal <- _balance;\n    f <- funded;\n    allowed = claimback_allowed bal goal f;\n    match allowed with\n    | False =>\n      ClaimBackFailure cannot_reclaim_code\n    | True =>\n      res <- backers[_sender];\n      match res with\n      | None =>\n        (* Sender has not donated *)\n        ClaimBackFailure cannot_reclaim_code\n      | Some v =>\n        PerformClaimBack v\n      end\n    end\n  end  \nend\n", "data": "[{\"vname\": \"_scilla_version\", \"type\": \"Uint32\", \"value\": \"0\"}, {\"vname\": \"owner\", \"type\": \"ByStr20\", \"value\": \"0x1c2c7516dac2140c47cbae264e8349bb7c07a534\"}, {\"vname\": \"max_block\", \"type\": \"BNum\", \"value\": \"1000\"}, {\"vname\": \"goal\", \"type\": \"Uint128\", \"value\": \"5000\"}]", "signature": "5973e74bd50f25928b52fe90c49e150e134761d0de4e5d040366050cfdf3dbed8fccad2d1d76c7cdf85f99930f9e0f6bdbaa9041043592be1ccc53ce2d8ecbd2", "priority": false}
{"version": 1, "nonce": 26, "toAddr": "0x0000000000000000000000000000000000000000", "amount": "0", "pubKey": "021e269b1a1509b417cd97795176235d948af40cbcf9ac1393aa02caa5e86c5177", "gasPrice": "100", "gasLimit": "20000", "code": "scilla_version 0\n\n(***************************************************)\n(*               Associated library                *)\n(***************************************************)\nimport BoolUtils\nlibrary NonfungibleToken\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint256 0\nlet one = Uint256 1\n\nlet addOwnerCount = \n  fun (someCurrentCount: Option Uint256) =>\n    match someCurrentCount with\n    | Some currentCount =>\n      builtin add currentCount one\n    | None => one\n    end\n\nlet subOwnerCount = \nfun (someCurrentCount: Option Uint256) =>\n  match someCurrentCount with\n  | Some currentCount =>\n    let is_zero = builtin eq currentCount zero in\n    match is_zero with\n    | True => None { Uint256 }\n    | False => \n      let new_count = builtin sub currentCount one in\n      Some { Uint256 } new_count\n    end\n  | None => None { Uint256 }\n  end\n\n(* Check if a sender is an operator of the owner, approved for the given ID *)\n(* or is the owner of the token                                             *)\nlet isApprovedOrOwner =\n  fun (isOwner: Bool) =>\n  fun (isApproved: Bool) =>\n  fun (isApprovedForAll: Bool) =>\n    let isOwnerOrApproved =  orb isOwner isApproved in\n    orb isOwnerOrApproved isApprovedForAll\n\n(* Error events *)\ntype Error =\n  | CodeNotAuthorised\n  | CodeNotFound\n  | CodeTokenExists\n  | CodeUnexpectedError\n\nlet makeErrorEvent =\n  fun (result : Error) =>\n    let result_code = \n      match result with\n      | CodeNotAuthorised    => Int32 -1\n      | CodeNotFound         => Int32 -2\n      | CodeTokenExists      => Int32 -3\n      | CodeUnexpectedError  => Int32 -4\n      end\n    in\n    { _eventname : \"Error\"; code : result_code }\n\n(***************************************************)\n(*             The contract definition             *)\n(***************************************************)\n\ncontract NonfungibleToken\n(contractOwner: ByStr20,\n  name : String,\n  symbol: String\n)\n\n(* Mutable fields *)\n\n(* Mapping between tokenId to token owner *)\nfield tokenOwners: Map Uint256 ByStr20 = Emp Uint256 ByStr20\n\n(* Mapping from owner to number of owned tokens *)\n(* field ownedTokenCount: Map ByStr20 Uint256 = Emp ByStr20 Uint256 *)\n\n(* Mapping between tokenId to approved address *)\n(* @dev: There can only be one approved address per token at any given time. *)\nfield tokenApprovals: Map Uint256 ByStr20 = Emp Uint256 ByStr20\n\n(* Mapping from owner to operator approvals  *)\nfield operatorApprovals: Map ByStr20 (Map ByStr20 Bool)\n                            = Emp ByStr20 (Map ByStr20 Bool)\n\n(* Emit Errors *)\nprocedure MakeError(err : Error)\n  e = makeErrorEvent err;\n  event e\nend\n\n(* @dev:    Mint new tokens. Only contractOwner can mint. *)\n(* @param:  to      - Address of the token recipient      *)\n(* @param:  tokenId - ID of the new token minted          *)\n(* Returns error message CodeTokenExists if token exists. *)\n(* Revert transition if invalid recipient contract.       *)\ntransition mint(to: ByStr20, tokenId: Uint256)\n  (* Check if token exists *)\n  tokenExist <- exists tokenOwners[tokenId];\n  match tokenExist with\n  | True =>\n    (* Token exists, return error code *)\n    err = CodeTokenExists;\n    MakeError err\n  | False =>\n    (* Check if sender is contractOwner *)\n    isContractOwner = builtin eq _sender contractOwner;\n    match isContractOwner with\n    | True =>\n      (* Mint new token *)\n      tokenOwners[tokenId] := to;\n      (* Add to owner's count *)\n      (* someCurrentCount <- ownedTokenCount[to];\n      newCount = addOwnerCount someCurrentCount;\n      ownedTokenCount[to] := newCount; *)\n      (* Emit success event *)\n      e = {_eventname: \"MintSuccess\"; by: _sender; recipient: to; token: tokenId};\n      event e;\n      (* Send dummy callback message.                                                *)\n      (* Revert transition if invalid recipient contract. Ignore if external address *)\n      msg = { _tag : \"transferCallBack\"; _recipient : to; _amount : Uint128 0 };\n      msgs = one_msg msg;\n      send msgs\n    | False =>\n      (* Unauthorised transaction*)\n      err = CodeNotAuthorised;\n      MakeError err\n    end\n  end\nend\n\n(* @dev:    Burn existing tokens. Only tokenOwner or approved operator can burn a token *)\n(* @param:  tokenId - ID of the new token destroyed                                     *)\n(* Returns error message CodeNotFound if token does not exists                          *)\ntransition burn(tokenId: Uint256)\n  (* Check if token exists *)\n  getTokenOwner <- tokenOwners[tokenId];\n  match getTokenOwner with\n  | None =>\n    (* Token do not exist, return error code *)\n    err = CodeNotFound;\n    MakeError err\n  | Some tokenOwner =>\n    (* Check if sender is tokenOwner *)\n    isOwner = builtin eq _sender tokenOwner;\n    (* Check if sender is tokenOwner approvedForAll operator *)\n    getOperator <- operatorApprovals[tokenOwner][_sender];\n    isApprovedForAll = match getOperator with\n      | None => False\n      | Some val => val\n      end;\n    (* Check if sender is an authorised *)\n    isAuthorised = orb isOwner isApprovedForAll;\n    match isAuthorised with\n    | False =>\n      (* Unauthorised transaction *)\n      err = CodeNotAuthorised;\n      MakeError err\n    | True =>\n      (* Destroy existing token *)\n      delete tokenOwners[tokenId];\n      delete tokenApprovals[tokenId];\n      e = {_eventname: \"BurnSuccess\"; by: _sender; token: tokenId};\n      event e\n    end\n  end\nend\n\n(* @dev: Transfer the ownership of a given tokenId to another address *)\n(* @param: to      - Recipient address for the token                  *)\n(* @param: tokenId - ID of the token to be transferred                *)\n(* Returns error message CodeNotFound if token does not exists        *)\n(* Revert transition if invalid recipient contract.                   *)\ntransition transfer(tokenOwner: ByStr20, to: ByStr20, tokenId: Uint256)\n  (* Check if token exists *)\n  getTokenOwner <- tokenOwners[tokenId];\n  match getTokenOwner with\n  | None =>\n    (* Token does not exists, return error code *)\n    err = CodeNotFound;\n    MakeError err\n  | Some correctOwner =>\n    isCorrectOwner = builtin eq tokenOwner correctOwner;\n    match isCorrectOwner with\n    | False => throw\n    | True =>\n    (* Check if sender is tokenOwner *)\n    isOwner = builtin eq _sender tokenOwner;\n    getTokenApproval <- tokenApprovals[tokenId];\n    isApproved = match getTokenApproval with\n      | None => False\n      | Some approvedAddress => \n        (* Check if sender is an approved address *)\n        builtin eq _sender approvedAddress\n      end;\n    (* Check if sender is tokenOwner approvedForAll operator *)\n    getOperatorStatus <- operatorApprovals[tokenOwner][_sender];\n    isApprovedForAll = match getOperatorStatus with\n      | None => False\n      | Some val => val\n      end;\n    (* Check if sender is an authorised personnel *)\n    isAuthorised = isApprovedOrOwner isOwner isApproved isApprovedForAll;\n    match isAuthorised with\n    | False =>\n      (* Unauthorised transaction*)\n      err = CodeNotAuthorised;\n      MakeError err\n    | True =>\n      (* Change tokenOwner for that tokenId *)\n      tokenOwners[tokenId] := to;\n      (* Delete tokenApproval entry for that tokenId *)\n      delete tokenApprovals[tokenId];\n      e = {_eventname: \"TransferSuccess\"; from: _sender; recipient: to; token: tokenId};\n      event e;\n      (* Send dummy callback message.                                                *)\n      (* Revert transition if invalid recipient contract. Ignore if external address *)\n      msg = { _tag : \"transferCallBack\"; _recipient : to; _amount : Uint128 0 };\n      msgs = one_msg msg;\n      send msgs\n    end\n    end\n  end\nend\n\n(* @dev: Approves another address the ability to transfer the given tokenId *)\n(* There can only be one approvedSpender per token at a given time          *)\n(* Absence of entry in tokenApproval indicates there is no approved address *)\n(* param: to      - Address to be approved for the given tokenId            *)\n(* param: tokenId - ID of the token to be approved                          *)\ntransition approve(to: ByStr20, tokenId: Uint256)\n  (* Get tokenOwner address *)\n  getTokenOwner <- tokenOwners[tokenId];\n  match getTokenOwner with\n  | None =>\n    (* Token not found *)\n    err = CodeNotFound;\n    MakeError err\n  | Some tokenOwner =>\n    isOwner = builtin eq _sender tokenOwner;\n    getApprovedForAll <- operatorApprovals[tokenOwner][_sender];\n    isApprovedForAll = match getApprovedForAll with\n      | Some val => val\n      | None => False\n      end;\n    isAuthorised = orb isOwner isApprovedForAll;\n    match isAuthorised with\n    | True =>\n      (* Add to tokenApproval mapping *)\n      tokenApprovals[tokenId] := to;\n      (* Emit event *)\n      e = {_eventname: \"ApproveSuccess\"; from: _sender; approvedTo: to; token: tokenId};\n      event e\n    | False =>\n      (* Unauthorised transaction *)\n      err = CodeNotAuthorised;\n      MakeError err\n    end\n  end\nend\n\n(* @dev: Sets or unsets the approval of a given operator           *)\n(* @param: to       - Address to be set or unset as operator       *)\n(* @param: approved - Status of approval to be set for the address *)\ntransition setApprovalForAll(to: ByStr20, approved: Bool)\n  (* Checks if the _sender is approving himself *)\n  isValidOperation = let check = builtin eq _sender to in negb check;\n  (* Require the approval to not be the _sender *)\n  match isValidOperation with\n  | True =>\n    (* Check if _sender has an existing record on the operatorApproval *)\n    operatorApprovals[_sender][to] := approved;\n    (* Stringify boolean value to be emitted in the event *)\n    approvedStr = bool_to_string approved;\n    e = {_eventname: \"SetApprovalForAllSuccess\"; by: _sender; recipient: to; status: approvedStr};\n    event e\n  | False =>\n    err = CodeNotAuthorised;\n    MakeError err\n  end\nend", "data": "[{\"vname\": \"_scilla_version\", \"type\": \"Uint32\", \"value\": \"0\"}, {\"vname\": \"_sharding_input\", \"type\": \"String\", \"value\": \"{\\\"transitions\\\" : [\\\"mint\\\", \\\"transfer\\\"]}\"}, {\"vname\": \"contractOwner\", \"type\": \"ByStr20\", \"value\": \"0x1c2c7516dac2140c47cbae264e8349bb7c07a534\"}, {\"vname\": \"name\", \"type\": \"String\", \"value\": \"CryptoKatz\"}, {\"vname\": \"symbol\", \"type\": \"String\", \"value\": \"KATZ\"}]", "signature": "363b4ce966f1f8439dce025656a3f0b1d745234fc709fd3dc5b4061b40fb86f12b6b3effc7ef8c3ce47d3542d3c6201de43bb86c272a73c8b95dc9763a3953e9", "priority": false}
{"version": 1, "nonce": 27, "toAddr": "0x0000000000000000000000000000000000000000", "amount": "0", "pubKey": "021e269b1a1509b417cd97795176235d948af40cbcf9ac1393aa02caa5e86c5177", "gasPrice": "100", "gasLimit": "20000", "code": "scilla_version 0\n\n(* ProofIPFS Contract *)\n\nimport PairUtils ListUtils BoolUtils\n\n(***************************************************)\n(*               Associated library                *)\n(***************************************************)\nlibrary ProofIPFS\n\nlet one  = Uint128 1\nlet zero = Uint128 0\n\n(* error codes library *)\nlet code_success            = Uint32 0\nlet code_item_not_found     = Uint32 1\nlet code_not_authorized     = Uint32 2\nlet code_invalid_params     = Uint32 3\nlet code_already_registered = Uint32 4\nlet code_amount_wrong       = Uint32 5\n\nlet code_cannot_get_funds   = Uint32 11\n\n\nlet fst_f = @fst (ByStr20) (BNum)\nlet snd_f = @snd (ByStr20) (BNum)\n\nlet not_eq =\n    fun (a : String) =>\n    fun (b : String) =>\n        let r = builtin eq a b in\n\t\tnegb r\n\nlet one_msg =\n\tfun (msg : Message) =>\n\t\tlet nil_msg = Nil {Message} in\n\t\tCons {Message} msg nil_msg\n\nlet one_element_list =\n\tfun (item : String) =>\n\t\tlet nil_item = Nil {String} in\n\t\tCons {String} item nil_item\n\n\n(***************************************************)\n(*             The contract definition             *)\n(***************************************************)\ncontract ProofIPFS\n(owner: ByStr20)\n\n(* store the price for a registration, start with 0 ZIL             *)\nfield price: Uint128 = Uint128 0\n\n(* ipfsInventory will store a Map of Items                          *)\n(*     String  ipfs_cid (index)                                     *)\n(*     ByStr20 registered account address                           *)\n(*     BNum    block_number of registration                         *)\n\nfield ipfsInventory: Map String (Pair (ByStr20) (BNum))\n                   = Emp String (Pair (ByStr20) (BNum))\n\n(* mapping each account to a list of registered items / IPFS files  *)\n\nfield registered_items: Map ByStr20 List(String)\n                      = Emp ByStr20 List(String)\n\n(* ======== transitions ===============*)\n\n(* @notice: allow anybody to request the price for a registration  *)\n(* @param : no parameter                                           *)\n(* @return: (Uint128) registration_price                           *) \n\ntransition getPrice()\n\tregistration_price <- price;\n\te = {_eventname: \"getPrice\"; price: registration_price};\n\tevent e\nend\n\n\n(* @notice: Allows `_sender` to register ownership for a IPFS file *)\n(* @dev   : No ccess controls - anybody is allowed to register     *)\n(* @dev   : amount has to be send matching the current price       *)\n(* @param : (String) ipfs_cid : IPFS CID (hash) of item (file)     *)\n(* @return: (Uint32) code                                          *)\n\ntransition registerOwnership(ipfs_cid: String)\n\n\tregistration <- ipfsInventory[ipfs_cid];\n\tmatch registration with\n\t| Some v =>\n\t\te = {_eventname : \"registerOwnership\"; code : code_already_registered};\n\t\tevent e\n\t| None =>\n\t\tcurrent_price <- price;\n\t\tpayment_ok = builtin eq current_price _amount;\n\t\tmatch payment_ok with\n\t\t| True =>\n\t\t\taccept;\n\t\t\t(* Creating a new Item Model *)\n\t\t\t(* A new item model is a Pair of address (_sender) and block_number *)\n\t\t\tblock_number <- & BLOCKNUMBER;\n\t\t\tnew_item = Pair {(ByStr20) (BNum)} _sender block_number;\n\n\t\t\t(* Add the new item to the item_inventory Map, with ipfs_cid as the key   *)\n\t\t\tipfsInventory[ipfs_cid] := new_item;\n\n\t\t\t(* update registered_items list for _sender account *)\n\t\t\tcurrent_list <- registered_items[_sender];\n\n\t\t\tmatch current_list with\n\t\t\t| Some v =>\n\t\t\t\tnew_list = Cons {String} ipfs_cid v;\n\t\t\t\tregistered_items[_sender] := new_list\n\t\t\t| None =>\n\t\t\t\tnew_list = one_element_list ipfs_cid;\n\t\t\t\tregistered_items[_sender] := new_list\n\t\t\tend;\n\n\t\t\te = {_eventname : \"registerOwnership\"; code : code_success};\n\t\t\tevent e\n\n\t\t| False =>\n\t\t\te = {_eventname : \"registerOwnership()_amount_wrong\"; code: code_amount_wrong; current_price: current_price; amount: _amount};\n\t\t\tevent e\n\t\tend\n\tend\nend\n\n\n(* @notice: get registration info for IPFS file                            *)\n(* @dev   : No ccess controls - anybody is allowed to get that information *)\n(* @param : (String) ipfs_cid : IPFS CID (hash) of item (file)             *)\n(* @return: Pair {(ByStr20) (BNum)} address block_number , (Uint32) code   *)\n\ntransition getRegistration(ipfs_cid: String)\n\n\tregistration <- ipfsInventory[ipfs_cid];\n\tmatch registration with\n\t| Some v =>\n\t\t(* v contains (address, block_number) (Pair (ByStr20) (BNum)) *)\n\t\te = {_eventname: \"getRegistration_success\"; code: code_success; msg: v};\n\t\tevent e\n\n\t| None =>\n\t\te = {_eventname: \"getRegistration_item_not_found\"; code: code_item_not_found};\n\t\tevent e\n\n\tend\nend\n\n\n(* @notice: get registered items for a given account                       *)\n(* @dev   : No ccess controls - anybody is allowed to get that information *)\n(* @param : (ByStr20) account                                              *)\n(* @return: List(String) ipfs_cid                                          *)\n\ntransition getItemList(account: ByStr20)\n\n\titem_list <- registered_items[_sender];\n\tmatch item_list with\n\t| Some v =>\n\t\te = {_eventname: \"getItemList()\"; code: code_success; item_list: v};\n\t\tevent e\n\n\t| None =>\n\t\te = {_eventname: \"getItemList()_account_not_found\"; code: code_item_not_found};\n\t\tevent e\n\n\tend\nend\n\n\n(* @notice: Delete a registration for a IPFS file                          *)\n(* @dev   : only account address which registered ownership can delete     *)\n(* @param : (String) ipfs_cid : IPFS CID (hash) of item (file)             *)\n(* @return: (Uint32) code                                                  *)\n\ntransition deleteRegistration(ipfs_cid: String)\n\n\tregistration <- ipfsInventory[ipfs_cid];\n\tmatch registration with\n\t| Some v =>\n\t\treg_address  = fst_f v;\n\t\thas_registered = builtin eq reg_address _sender;\n\n\t\tmatch has_registered with\n\t\t| True =>\n\t\t\t(* delete entry in Map holding all ipfs_cid *)\n\t\t\tdelete ipfsInventory[ipfs_cid];\n\n\t\t\t(* update Map registered_items for _sender account             *)\n\t\t\t(* current list contains all ipfs_cid that user has registered *)\n\t\t\tcurrent_list <- registered_items[_sender];\n\n            match current_list with\n            | Some l =>\n                list_filter_String = @list_filter String;\n                f = not_eq ipfs_cid;\n                new_list = list_filter_String f l;\n                registered_items[_sender] := new_list;\n                e = {_eventname: \"deleteRegistration\"; code: code_success};\n\t\t\t    event e\n\n            | None =>\n            \te = {_eventname: \"deleteRegistration\"; code: code_item_not_found};\n\t\t        event e\n            end\n\n\t\t| False =>\n\t\t\te = {_eventname: \"deleteRegistration\"; code: code_not_authorized};\n\t\t\tevent e\n\t\tend\n\n\t| None =>\n\t\te = {_eventname: \"deleteRegistration\"; code: code_item_not_found};\n\t\tevent e\n\tend\n\nend\n\n\n(* @notice: allows owner of contract to set the price for a registration *)\n(* @param : new_price : Uint128                                          *)\n(* @return: (Uint32) code                                                *) \n\ntransition setPrice (new_price : Uint128)\n\tis_owner = builtin eq owner _sender;\n\tmatch is_owner with\n\t| False =>\n\t\te = {_eventname : \"setPrice()\"; code : code_not_authorized};\n\t\tevent e\n\t| True =>\n\t\tprice := new_price;\n\t\te = {_eventname : \"setPrice()\"; code : code_success};\n\t\tevent e\n\tend\nend\n\n\n(* @notice: allows owner of contract to get the current balance of contract *)\n(* @param : no parameter                                                    *)\n(* @return: (Uint128) balance                                               *) \n\ntransition getBalance ()\n\tis_owner = builtin eq owner _sender;\n\tmatch is_owner with\n\t| False =>\n\t\te = {_eventname : \"getBalance()_not_authorized\"; code : code_not_authorized};\n\t\tevent e\n\t| True =>\n\t\tbal <- _balance;\n\t\te = {_eventname : \"getBalance()\"; balance : bal; code : code_success};\n\t\tevent e\n\tend\nend\n\n\n(* @notice: allows owner of contract to get funds of contract            *)\n(* @param : no paramter                                                  *)\n(* @return: (Uint32) code                                                *)\n\ntransition getFunds ()\n\tis_owner = builtin eq owner _sender;\n\tmatch is_owner with\n\t| False =>\n\t\te = {_eventname : \"getFunds()_not_authorized\"; code : code_not_authorized};\n\t\tevent e\n\t| True =>\n\t\tbal <- _balance;\n\t\te = {_eventname : \"getFunds()_transfer_initiated\"; recipient_address: owner; amount: bal; code: code_success};\n\t\tevent e;\n\t\tmsg = {_tag : \"\"; _recipient : owner; _amount : bal; code : code_success};\n\t\tmsgs = one_msg msg;\n\t\tsend msgs\n\tend\nend\n\n\ntransition getContractAddress()\n\te = {_eventname : \"getContractAddress\"; contract_address : _this_address };\n\tevent e\nend\n\n\ntransition getOwnerAddress()\n\te = {_eventname : \"getOwnerAddress\"; owner_address : owner };\n\tevent e\nend\n", "data": "[{\"vname\": \"_scilla_version\", \"type\": \"Uint32\", \"value\": \"0\"}, {\"vname\": \"_sharding_input\", \"type\": \"String\", \"value\": \"{\\\"transitions\\\" : [\\\"registerOwnership\\\"]}\"}, {\"vname\": \"owner\", \"type\": \"ByStr20\", \"value\": \"0x1c2c7516dac2140c47cbae264e8349bb7c07a534\"}]", "signature": "3b81498c1cc1919619db40d1650118461ff3f78f87b0bc0f19748f8a80a5b558fa566da53bc6c61aa5d29913501747e6858f70cbe2e0f8c25f596de4345396e6", "priority": false}
{"version": 1, "nonce": 28, "toAddr": "0x0000000000000000000000000000000000000000", "amount": "0", "pubKey": "021e269b1a1509b417cd97795176235d948af40cbcf9ac1393aa02caa5e86c5177", "gasPrice": "100", "gasLimit": "20000", "code": "scilla_version 0\n\nimport BoolUtils ListUtils\n\nlibrary RegistryLib\n\n(* The PsudoStandardLib is a standard list of values that we have defined for *)\n(* all scilla contracts see scilla/psuedo_standard.scillib for all the details *)\n\nlet zeroUint64 = Uint64 0\nlet zeroByStr20 = 0x0000000000000000000000000000000000000000\nlet zeroByStr32 =\n  0x0000000000000000000000000000000000000000000000000000000000000000\nlet nilByStr20 = Nil {ByStr20}\nlet nilMessage = Nil {Message}\n\nlet oneMsg =\n  fun(msg: Message) =>\n    Cons {Message} msg nilMessage\n\nlet eqByStr32 =\n  fun(bs1: ByStr32) =>\n  fun(bs2: ByStr32) =>\n    builtin eq bs1 bs2\n\n(* XAND Gate *)\nlet xandb =\n  fun(b1: Bool) =>\n  fun(b2: Bool) =>\n    match b1 with\n    | True =>\n      match b2 with\n      | True => True\n      | False => False\n      end\n    | False =>\n      match b2 with\n      | True => False\n      | False => True\n      end\n    end\n\n(* Events defines a the \"constructors\" for all the types of events used *)\n(* inside ZNS *)\nlet eAdminSet =\n  fun(address: ByStr20) =>\n  fun(isApproved: Bool) =>\n    {_eventname: \"AdminSet\"; address: address; isApproved: isApproved}\n\nlet eApprovedFor =\n  fun(user: ByStr20) =>\n  fun(operator: ByStr20) =>\n  fun(isApproved: Bool) =>\n    {_eventname: \"ApprovedFor\"; user: user; operator: operator; isApproved: isApproved}\n\nlet eApproved =\n  fun(address: ByStr20) =>\n    {_eventname: \"Approved\"; address: address}\n\nlet eNewRegistrar =\n  fun(address: ByStr20) =>\n    {_eventname: \"NewRegistrar\"; address: address}\n\nlet eNewDomain =\n  fun(parent: ByStr32) =>\n  fun(label: String) =>\n    {_eventname: \"NewDomain\"; parent: parent; label: label}\n\nlet eConfigured =\n  fun(node: ByStr32) =>\n  fun(owner: ByStr20) =>\n  fun(resolver: ByStr20) =>\n    {_eventname: \"Configured\"; node: node; owner: owner; resolver: resolver}\n(* We use the Error event to alert the caller if something went wrong because *)\n(* Scilla doesn't support throwing *)\nlet eError =\n  fun(msg: String) =>\n    {_eventname: \"Error\"; msg: msg }\n\ntype Unit =\n| Unit\n\nlet unit = Unit\n\nlet getByStr20 =\n  fun(maybeAddr: Option ByStr20) =>\n    match maybeAddr with\n    | None => zeroByStr20\n    | Some addr => addr\n    end\n\nlet parentLabelToNode =\n  fun(parent: ByStr32) =>\n  fun(label: String) =>\n    let labelHash = builtin sha256hash label in\n    let nodeInput = builtin concat parent labelHash in\n      builtin sha256hash nodeInput\n\nlet getIsOAO =\n  fun(sender: ByStr20) =>\n  fun(recordOwner: ByStr20) =>\n  fun(maybeApproved: Option ByStr20) =>\n  fun(isOperator: Bool) =>\n    let isOwner = builtin eq sender recordOwner in\n    let isApproved =\n      match maybeApproved with\n      | None => False\n      | Some approved => builtin eq sender approved\n      end in\n    let b1 = orb isOwner isApproved in orb b1 isOperator\n\n\n(* The 'contract' pragma tells scilla that the contract body starts *)\ncontract Registry\n\n(* Initial Parameters are specified on deploy, in the init.json and cannot be *)\n(* changed throughout the life of the contract *)\n\n(* initialOwner specifies the owner of the ZNS Root. See records field below. *)\n(initialOwner: ByStr20, rootNode: ByStr32)\n\n(* Mutable Fields represent the persistant state of a scilla contract and can *)\n(* use the Initial Parameters durring contract instantiation *)\n\n(* records is the representation of the ZNS record tree as a mapping of a *)\n(* Node IDs (ByStr32) to ZNS records (Record) *)\n(* We initialize the field, so the contracts' initialOwner owns the ZNS root *)\nfield record_owner: Map ByStr32 ByStr20 =\n  let empty = Emp ByStr32 ByStr20 in\n  builtin put empty rootNode initialOwner\n\nfield record_resolver: Map ByStr32 ByStr20 =\n  let empty = Emp ByStr32 ByStr20 in\n  builtin put empty rootNode zeroByStr20\n\nfield registrar: ByStr20 = zeroByStr20\n\n(* approvals and operators are the internal representation of the ERC721 like *)\n(* IAM system that ZNS uses *)\nfield approvals: Map ByStr32 ByStr20 = Emp ByStr32 ByStr20\nfield operators: Map ByStr20 (Map ByStr20 Unit) = Emp ByStr20 (Map ByStr20 Unit)\nfield admins: Map ByStr20 Unit =\n  let emp_map = Emp ByStr20 Unit in\n  builtin put emp_map initialOwner unit\n\n(* Adds or removes the given address as the contract admin based on isApproved flag *)\n(* @ensures sender address is an admin *)\n(* @param address the address to be added as admin *)\n(* @param isApproved when true the address is added to admins, otherwise the address removed from admins *)\n(* @emits adminSet with address and isApproved flag when the new admin was assigned or removed *)\n(* @emits Error when sender address has no permission for this operation *)\ntransition setAdmin(address: ByStr20, isApproved: Bool)\n  isSenderAdmin <- exists admins[_sender];\n\n  match isSenderAdmin with\n  | True =>\n      match isApproved with\n      | True => admins[address] := unit\n      | False => delete admins[address]\n      end;\n      e = eAdminSet address isApproved;\n      event e\n  | False =>\n    e = let m = \"Sender not root node owner\" in eError m;\n    event e\n  end\nend\n\n(* Allows the nodes' owner to approve of one address to freely configure a node *)\n(* @ensures sender address is an owner of the node *)\n(* @param node *)\n(* @param address  *)\n(* @emits Approved when the new approved address is set *)\n(* @emits Error when sender address has no permission for this operation *)\ntransition approve(node: ByStr32, address: ByStr20)\n  maybeRecordOwner <- record_owner[node];\n  recordOwner = getByStr20 maybeRecordOwner;\n  isSenderNodeOwner = builtin eq _sender recordOwner;\n\n  match isSenderNodeOwner with\n  | True =>\n      approvals[node] := address;\n      e = eApproved address;\n      event e\n  | False =>\n    e = let m = \"Sender not node owner\" in eError m;\n    event e\n  end\nend\n\n(* Allows the sender account to approve or unapprove an address to act on it's behalf. *)\n(* @param address  *)\n(* @param isApproved when true the address is added to the list operators otherwise removed  *)\n(* @emits ApprovedFor when the new approved address is added or removed from operators based on isApproved flag*)\ntransition approveFor(address: ByStr20, isApproved: Bool)\n  match isApproved with\n  | True => operators[_sender][address] := unit\n  | False => delete operators[_sender][address]\n  end;\n  e = eApprovedFor _sender address isApproved;\n  event e\nend\n\n(* Configures an existing node owner and resolver *)\n(* @ensures sender address is an owner of the node or one of owner's operators or an approved address for the node *)\n(* @param node address of the node to be configured*)\n(* @param owner a new owner of the node *)\n(* @param resolver a new resolver address of the node *)\n(* @sends onConfigureSuccess to the sender if it was successfully changed *)\n(* @sends onConfigureFailure to the sender if it failed to change *)\n(* @emits Configured the operation was successful *)\n(* @emits Error when sender address has no permission for this operation *)\ntransition configureNode(node: ByStr32, owner: ByStr20, resolver: ByStr20)\n  maybeRecordOwner <- record_owner[node];\n  recordOwner = getByStr20 maybeRecordOwner;\n  maybeApproved <- approvals[node];\n  isOperator <- exists operators[recordOwner][_sender];\n\n  isSenderOAO = getIsOAO _sender recordOwner maybeApproved isOperator;\n\n  match isSenderOAO with\n  | True =>\n    record_owner[node] := owner;\n    record_resolver[node] := resolver;\n    e = eConfigured node owner resolver;\n    event e;\n    msgs = let m = {_tag: \"onConfigureSuccess\"; node: node; owner: owner;\n                    _amount: Uint128 0; _recipient: _sender}\n      in oneMsg m;\n    send msgs\n\n  | False =>\n    e = let m = \"Sender not node owner, approved or operator\" in eError m;\n    event e;\n    msgs = let m = {_tag: \"onConfigureFailure\"; node: node; owner: recordOwner;\n                    _amount: Uint128 0; _recipient: _sender}\n      in oneMsg m;\n    send msgs\n  end\nend\n\n(* Configures an existing node resolver *)\n(* @ensures sender address is an owner of the node or one of owner's operators or an approved address for the node *)\n(* @param node address of the node to be configured *)\n(* @param resolver a new resolver address of the node *)\n(* @emits Configured if the node's resolver was changed successfully*)\n(* @emits Error when a sender address has no permission for this operation *)\ntransition configureResolver(recordOwner: ByStr20, node: ByStr32, resolver: ByStr20) \n  maybeRecordOwner <- record_owner[node];\n  nodeOwner = getByStr20 maybeRecordOwner;\n\n  isCorrectOwner = builtin eq nodeOwner recordOwner;\n  match isCorrectOwner with\n  | False => throw\n  | True =>\n\n  maybeApproved <- approvals[node];\n  isOperator <- exists operators[recordOwner][_sender];\n\n  isSenderOAO = getIsOAO _sender recordOwner maybeApproved isOperator;\n\n  match isSenderOAO with\n  | True =>\n    record_owner[node] := recordOwner;\n    record_resolver[node] := resolver;\n    e = eConfigured node recordOwner resolver;\n    event e\n\n  | False =>\n    e = let m = \"Sender not node owner, approved or operator\" in eError m;\n    event e\n  end\n  end\nend\n\n(* Transfer an existing node to an owner *)\n(* @ensures sender address is an owner of the node or one of node's owner operators or an approved address of this node *)\n(* @param node address of the node to be configured *)\n(* @param owner a new owner of the node *)\n(* @sends onTransferSuccess to the sender if it was successfully changed *)\n(* @sends onTransferFailure to the sender if it failed to change *)\n(* @emits Configured if the node's owner was changed successfully*)\n(* @emits Error when a sender address has no permission for this operation *)\ntransition transfer(node: ByStr32, owner: ByStr20)\n  maybeRecordOwner <- record_owner[node];\n  recordOwner = getByStr20 maybeRecordOwner;\n  maybeApproved <- approvals[node];\n  isOperator <- exists operators[recordOwner][_sender];\n\n  isSenderOAO = getIsOAO _sender recordOwner maybeApproved isOperator;\n\n  match isSenderOAO with\n  | True =>\n    delete approvals[node];\n    record_owner[node] := owner;\n    record_resolver[node] := zeroByStr20;\n\n    e = eConfigured node owner zeroByStr20;\n    event e;\n    msgs = let m = {_tag: \"onTransferSuccess\"; node: node; owner: owner;\n                    _amount: Uint128 0; _recipient: _sender}\n      in oneMsg m;\n    send msgs\n\n  | False =>\n    e = let m = \"Sender not node owner, approved or operator\" in eError m;\n    event e;\n    msgs = let m = {_tag: \"onTransferFailure\"; node: node; owner: owner;\n                    _amount: Uint128 0; _recipient: _sender}\n      in oneMsg m;\n    send msgs\n  end\nend\n\n(* Transfer a subnode to an account. This is the only way to create a new node. `assign` uses the same mechanics as `transfer` *)\n(* @ensures sender address is an owner of the parent node or one of parent node's owner operators or an approved address of parent node *)\n(* @param parent parent node address *)\n(* @param label a name of the subnode (subdomain) to be assigned *)\n(* @param owner an owner address of the subnode *)\n(* @sends onAssignSuccess to the sender if it was successfully changed *)\n(* @sends onAssignFailure to the sender if it failed to change *)\n(* @emits Configured if the node's owner was changed successfully*)\n(* @emits NewDomain when the target node(domain) didn't exist before and was made *)\n(* @emits Error when a sender address has no permission for this operation *)\ntransition assign(node: ByStr32, parent: ByStr32, label: String, owner: ByStr20)\n  maybeRecordOwner <- record_owner[node];\n  recordOwner = getByStr20 maybeRecordOwner;\n  maybeApproved <- approvals[parent];\n  isOperator <- exists operators[recordOwner][_sender];\n\n  isSenderOAO = getIsOAO _sender recordOwner maybeApproved isOperator;\n\n  match isSenderOAO with\n  | True =>\n    correct_node = parentLabelToNode parent label;\n    nodeComputedCorrectly = eqByStr32 node correct_node;\n\n    match nodeComputedCorrectly with\n    | False => throw\n    | True =>\n      recordExists <- exists record_owner[node];\n      match recordExists with\n      | False =>\n        e = eNewDomain parent label;\n        event e\n      | _ =>\n      end;\n\n      delete approvals[node];\n      record_owner[node] := owner;\n      record_resolver[node] := zeroByStr20;\n\n      e = eConfigured node owner zeroByStr20;\n      event e;\n\n      msgs = let m = {_tag: \"onAssignSuccess\"; parent: parent; label: label; \n                      owner: owner; _amount: Uint128 0; _recipient: _sender} \n        in oneMsg m;\n      send msgs\n    end\n  | False =>\n    e = let m = \"Sender not parent owner, approved or operator\" in eError m;\n    event e;\n\n    msgs = let m = {_tag: \"onAssignFailure\"; parent: parent; label: label; \n                    owner: recordOwner; _amount: Uint128 0; _recipient: _sender} \n      in oneMsg m;\n    send msgs\n  end\nend\n\n(* Transfer an unowned subnode to an account. *)\n(* @ensures a node is not owned by anyone or owned by registrar *)\n(* @ensures sender address is an admin or a registrar *)\n(* @param parent parent node address *)\n(* @param label a name of the subnode (subdomain) to be assigned *)\n(* @param owner a new owner address of the subnode *)\n(* @emits NewDomain when node(domain) was assigned to the new owner *)\n(* @emits Configured if the node's owner was changed successfully*)\n(* @emits Error when a sender address has no permission for this operation *)\ntransition bestow(node: ByStr32, label: String, owner: ByStr20, resolver: ByStr20)\n  correct_node = parentLabelToNode rootNode label;\n  nodeComputedCorrectly = eqByStr32 node correct_node;\n\n  match nodeComputedCorrectly with\n  | False => throw\n  | True =>\n    recordExists <- exists record_owner[node];\n    maybeRecordOwner <- record_owner[node];\n    recordOwner = getByStr20 maybeRecordOwner;\n    currentRegistrar <- registrar;\n    isSenderAdmin <- exists admins[_sender];\n\n    isOk =\n      let isSenderRegistrar = builtin eq currentRegistrar _sender in\n      let isOkSender = orb isSenderRegistrar isSenderAdmin in\n      let recordIsUnowned = builtin eq recordOwner zeroByStr20 in\n      let recordIsOwnedByRegistrar = builtin eq recordOwner currentRegistrar in\n      let isRegistrarSenderAndOwned = andb recordIsOwnedByRegistrar isSenderRegistrar in\n      let isOkRecordOwner = orb recordIsUnowned isRegistrarSenderAndOwned in\n        andb isOkSender isOkRecordOwner;\n\n    match isOk with\n    | True =>\n      match recordExists with\n      | False =>\n        e = eNewDomain rootNode label;\n        event e\n      | _ => \n      end;\n\n      (* delete approvals[node]; *)\n      record_owner[node] := owner;\n      record_resolver[node] := resolver;\n\n      e = eConfigured node owner resolver;\n      event e\n    | False =>\n      e = let m = \"Sender admin\" in eError m;\n      event e\n    end\n  end\nend\n\n(* Sets a new registrar for the registry *)\n(* @ensures the sender address is an admin *)\n(* @param address the new registrar address *)\n(* @emits NewRegistrar when the registrar was reassigned successfully *)\ntransition setRegistrar(address: ByStr20)\n  isOk <- exists admins[_sender];\n\n  match isOk with\n  | True => \n    e = eNewRegistrar address;\n    event e;\n    registrar := address\n  | _ => \n  end\nend\n\n(* Registers an new domain throw the registrar of the contract *)\n(* @param parent a parent address of the domain *)\n(* @param label the new domain name to be registered *)\n(* @ensures the new domain is not owned by anyone *)\n(* @ensures the new domain has no approved address *)\n(* @accepts the payment for the domain *)\n(* @sends register to the current registrar with the sent amount *)\ntransition register(node: ByStr32, parent: ByStr32, label: String)\n  correct_node = parentLabelToNode parent label;\n  nodeComputedCorrectly = eqByStr32 node correct_node;\n  match nodeComputedCorrectly with\n  | False => throw\n  | True =>\n    maybeApproved <- approvals[node];\n    maybeRecordOwner <- record_owner[node];\n    recordOwner = getByStr20 maybeRecordOwner;\n    approved =\n      match maybeApproved with\n      | None => zeroByStr20\n      | Some approved => approved\n      end;\n    currentRegistrar <- registrar;\n\n    isOk =\n      let isRecordUnowned = builtin eq recordOwner zeroByStr20 in\n      let isUnapproved = builtin eq approved zeroByStr20 in\n        andb isRecordUnowned isUnapproved;\n\n    match isOk with \n    | True =>\n      accept;\n      msgs =\n        let m = {_tag: \"register\"; _amount: _amount; _recipient: currentRegistrar;\n                origin: _sender; node: node; parent: parent; label: label} in\n          oneMsg m;\n      send msgs\n    | False =>\n    end\n  end\nend\n\n(* Callback method expected to be called by resolver when its configuration is changed *)\n(* @param node that has its resolver configured *)\n(* @ensures the node still has the _sender as its resolver *)\n(* @emits Configured that can be used by 3rd parties to monitor changes in resolvers configuration all over the registry *)\ntransition onResolverConfigured(node: ByStr32)\n  maybeResolver <- record_resolver[node];\n  resolver = getByStr20 maybeResolver;\n  maybeOwner <- record_owner[node];\n  owner = getByStr20 maybeOwner;\n\n  isOk = builtin eq resolver _sender;\n  match isOk with\n  | True =>\n    e = eConfigured node owner resolver;\n    event e\n  | False =>\n  end\nend\n\n", "data": "[{\"vname\": \"_scilla_version\", \"type\": \"Uint32\", \"value\": \"0\"}, {\"vname\": \"_sharding_input\", \"type\": \"String\", \"value\": \"{\\\"transitions\\\" : [\\\"configureResolver\\\", \\\"bestow\\\"]}\"}, {\"vname\": \"initialOwner\", \"type\": \"ByStr20\", \"value\": \"0x1c2c7516dac2140c47cbae264e8349bb7c07a534\"}, {\"vname\": \"rootNode\", \"type\": \"ByStr32\", \"value\": \"0x0000000000000000000000000000000000000000000000000000000000000000\"}]", "signature": "6b77aa97bdeb927a4e8a549995eddaac9c5cddb22911ba478d29250cf0af2e62680687476d50a347ec27fbb742a46517cfdc4a3383ed8caa96f59e864b0c7870", "priority": false}
