scilla_version 0

import BoolUtils

library NonfungibleToken

type Product =
| Product of Uint256 Uint128 Uint128 Uint128 Uint128

let unlimited_supply = Uint128 0

let create_product =
  fun (_productId: Uint256) =>
  fun (_initialPrice: Uint128) =>
  fun (_initialInventoryQuantity: Uint128) =>
  fun (_supply: Uint128) =>
    let s = Uint128 0 in
    Product _productId _initialPrice _initialInventoryQuantity _supply s

type ChangeInventoryResult =
| ChangeInventoryFailed
| ChangeInventorySuccess of Product

let increment_inventory =
  fun (p: Product) =>
  fun (_inventoryAdjustment: Uint128) =>
    match p with
    | Product id price available supply sold =>
      let newInventoryLevel = builtin add available _inventoryAdjustment in
      let unlimited = builtin eq supply unlimited_supply in
      match unlimited with
      | True =>
        let np = Product id price newInventoryLevel supply sold in
        ChangeInventorySuccess np
      | False =>
        let ns = builtin add sold newInventoryLevel in
        let uvs = builtin lt supply ns in
        match uvs with
        | True => ChangeInventoryFailed
        | False =>
          let np = Product id price newInventoryLevel supply sold in
          ChangeInventorySuccess np
        end
      end
    end

let decrement_inventory =
  fun (p: Product) =>
  fun (_inventoryAdjustment: Uint128) =>
    match p with
    | Product id price available supply sold =>
      let newInventoryLevel = builtin sub available _inventoryAdjustment in
      let overflow = builtin lt available newInventoryLevel in
      match overflow with
      | True => ChangeInventoryFailed
      | False =>
        let np = Product id price newInventoryLevel supply sold in
        ChangeInventorySuccess np
      end
    end

type PurchaseInventoryResult =
| PurchaseInventoryFailed
| PurchaseInventorySuccess of Product
let purchase_one_unit_in_stock =
  fun (p: Product) =>
    match p with
    | Product id price available supply sold =>
      let os = builtin eq available unlimited_supply in
      match os with
      | True => PurchaseInventoryFailed
      | False =>
        let one = Uint128 1 in
        let ns = builtin add sold one in
        let na = builtin sub available one in
        let np = Product id price na supply ns in
        PurchaseInventorySuccess np
      end
    end

type DinoSeed =
| DinoSeed of Uint256 BNum

let one_msg =
 fun (msg : Message) =>
 let nil_msg = Nil {Message} in
Cons {Message} msg nil_msg

let checkContractOwner =
  fun (msgSender: ByStr20) =>
  fun (owner: ByStr20) =>
    builtin eq msgSender owner

let isTokenOwner =
  fun (msgSender: ByStr20) =>
  fun (tokenOwner : Option ByStr20) =>
    match tokenOwner with
    | None => False
    | Some val =>
      builtin eq val msgSender
    end

let isApproved =
  fun (msgSender: ByStr20) =>
  fun (val: Option ByStr20) =>
    match val with
    | None => False
    | Some val =>
      builtin eq val msgSender
    end

let isApprovedForAll =
  fun (msgSender: ByStr20) =>
  fun (m: Option (Map (ByStr20) (Bool))) =>
    match m with
    | None => False
    | Some val =>
      let check_list = builtin get val msgSender in
      match check_list with
      | None => False
      | Some is_sender_approved =>
        match is_sender_approved with
        | True => True
        | False => False
        end
      end
    end

let isApprovedOrOwner =
  fun (isOwner: Bool) =>
  fun (isApproved: Bool) =>
  fun (isApprovedForAll: Bool) =>
    let isOwnerOrApproved =  orb isOwner isApproved in
    orb isOwnerOrApproved isApprovedForAll

let isAuthorizedOrNotToContractHolder =
  fun (isAuthorized: Bool) =>
  fun (isToContracHoler: Option Bool) =>
    match isToContracHoler with
    | Some p =>
      match p with
      | True => isAuthorized
      | False => False
      end
    | None => isAuthorized
    end
    
let makeErrorEvent =
  fun (location: String) =>
  fun (errorCode: Uint32) =>
    {_eventname: "Error"; raisedAt: location; code: errorCode }

let code_success = Uint32 0
let code_failure = Uint32 1
let code_not_authorized = Uint32 2
let code_not_found = Uint32 4
let code_bad_request = Uint32 5
let code_token_exists = Uint32 6
let code_product_exists = Uint32 7
let code_invalid_quantity = Uint32 8
let code_unexpected_error = Uint32 9
let code_product_not_exists = Uint32 10

let code_purchase_error = Uint32 20

let code_not_implement_error = Uint32 255

contract NonfungibleToken
(owner : ByStr20,
name : String,
symbol: String
)

field tokenOwnerMap: Map Uint256 ByStr20 = Emp Uint256 ByStr20
field ownedTokenCount: Map ByStr20 Uint256 = Emp ByStr20 Uint256

field tokenApprovals: Map Uint256 ByStr20 = Emp Uint256 ByStr20

field operatorApprovals: Map ByStr20 (Map ByStr20 Bool)
              = Emp ByStr20 (Map ByStr20 Bool)

field dinoSeedMap: Map Uint256 DinoSeed = Emp Uint256 DinoSeed
field nonceSeed: Uint256 = Uint256 0

field productsMap: Map Uint256 Product = Emp Uint256 Product

field whilelistContractHolderMap: Map ByStr20 Bool = Emp ByStr20 Bool

transition balanceOf(address: ByStr20)
  optionBal <- ownedTokenCount[address];
  balance = match optionBal with
  | Some bal => bal
  | None => Uint256 0
  end;
  e = {_eventname: "balanceOf"; bal: balance};
  event e
end

transition ownerOf(tokenId: Uint256)
  someVal <- tokenOwnerMap[tokenId];
  match someVal with
  | Some val =>
    e = {_eventname: "ownerOf"; id: tokenId; owner: val};
    event e
  | None =>
    e = let raisedAt = "ownerOf" in makeErrorEvent raisedAt code_not_found;
    event e
  end
end

transition mint(to: ByStr20, tokenId: Uint256)
  isOwner = checkContractOwner owner _sender;
  isThisContract = checkContractOwner _this_address _sender;
  isAuthorized = orb isOwner isThisContract;
  match isAuthorized with
  | True =>
    tokenExist <- exists tokenOwnerMap[tokenId];
    match tokenExist with
    | True =>
      e = let raisedAt = "mint" in makeErrorEvent raisedAt code_token_exists;
      event e
    | False =>
      tokenOwnerMap[tokenId] := to;
      userCnt <- ownedTokenCount[to];
      match userCnt with
      | Some val =>
        newVal= let one = Uint256 1 in builtin add val one;
        ownedTokenCount[to] := newVal
      | None =>
        newVal = Uint256 1;
        ownedTokenCount[to] := newVal
      end;

      e = {_eventname: "Mint successful"; by: _sender; recipient: to; token: tokenId};
      event e
    end
  | False =>
    e = let raisedAt = "mint" in makeErrorEvent raisedAt code_not_authorized;
    event e
  end

end

transition transferFrom(from: ByStr20, to: ByStr20, tokenId: Uint256)
  copy_tokenOwner <- tokenOwnerMap[tokenId];
  copy_tokenApprovals <- tokenApprovals[tokenId];
  
  getTokenOwner <- tokenOwnerMap[tokenId];
  match getTokenOwner with
  | None =>
    e = let raisedAt = "transferFrom" in makeErrorEvent raisedAt code_not_found;
    event e
    
  | Some tokenOwner =>
    copy_operatorApproval <- operatorApprovals[tokenOwner];
    checkOwner = isTokenOwner _sender copy_tokenOwner;
    checkApproved = isApproved _sender copy_tokenApprovals;
    checkApprovedForAll = isApprovedForAll _sender copy_operatorApproval;

    isFromTokenOwner = builtin eq tokenOwner from;
    match isFromTokenOwner with
    | False =>
      e = let raisedAt = "transferFrom" in makeErrorEvent raisedAt code_bad_request;
      event e
    | True =>
      isAuthorized = isApprovedOrOwner checkOwner checkApproved checkApprovedForAll;
      isToContracHoler <- whilelistContractHolderMap[to];
      
      isAuthorized2 = isAuthorizedOrNotToContractHolder isAuthorized isToContracHoler;

      match isAuthorized2 with
      | True =>
        match checkApproved with
        | True =>
          delete tokenApprovals[tokenId]
        | False =>
        end;

        tokenOwnerMap[tokenId] := to;

        somePrevBal <- ownedTokenCount[from];
        match somePrevBal with
        | Some prevBal =>
          newBal  = let one = Uint256 1 in builtin sub prevBal one;
          ownedTokenCount[from] := newBal
        | None =>
          e = let raisedAt = "transferFrom" in makeErrorEvent raisedAt code_unexpected_error;
          event e
        end;

        userCnt <- ownedTokenCount[to];
        newVal = let one = Uint256 1 in match userCnt with
        | Some val =>
          builtin add val one
        | None => one
        end;
        ownedTokenCount[to] := newVal;
        
        match isToContracHoler with
        | Some _ =>
          seed <- dinoSeedMap[tokenId];
          match seed with
          | Some s =>
            match s with
            | DinoSeed genes bornBlock =>
              msg = {_tag : "onERC721Received";
                _recipient : to;
                _amount : Uint128 0;
                from : _sender;
                tokenId : tokenId;
                genes : genes;
                bornBlock : bornBlock};
              msgs = one_msg msg;
              send msgs
            end
          | None =>
          end
        | None =>
        end;
        
        e = {_eventname: "transferFrom successful"};
        event e
      | False =>
        e = let raisedAt = "transferFrom" in makeErrorEvent raisedAt code_not_authorized;
        event e
      end
    end
  end
end

transition approve(to: ByStr20, tokenId: Uint256)

  copy_tokenOwner <- tokenOwnerMap[tokenId];
  
  getTokenOwner <- tokenOwnerMap[tokenId];
  match getTokenOwner with
  | None =>
    e = let raisedAt = "approve" in makeErrorEvent raisedAt code_not_found;
    event e
  | Some tokenOwner =>
    copy_operatorApproval <- operatorApprovals[tokenOwner];
    checkApprovedForAll = isApprovedForAll _sender copy_operatorApproval;
    checkOwner = isTokenOwner _sender copy_tokenOwner;
    isAuthorized = orb checkApprovedForAll checkOwner;
    match isAuthorized with
    | True =>
      tokenApprovals[tokenId] := to;
      e = {_eventname: "Approve successful"; from: _sender; approvedTo: to; token: tokenId};
      event e
    | False =>
      e = let raisedAt = "approve" in makeErrorEvent raisedAt code_not_authorized;
      event e
    end
  end
end

transition setApprovalForAll(to: ByStr20, approved: Bool)
  
  isValidOperation = let check = builtin eq _sender to in negb check;
  match isValidOperation with
  | True =>
    operatorApprovals[_sender][to] := approved;
    approvedStr = bool_to_string approved;
    e = {_eventname: "setApprovalForAll successful"; from: _sender; recipient: to; status: approvedStr};
    event e
  | False =>
    e = let raisedAt = "setApprovalForAll" in makeErrorEvent raisedAt code_not_authorized;
    event e
  end
end

transition setContractHolderStatus(to: ByStr20, approved: Bool)
  isAuthorized = checkContractOwner owner _sender;
  match isAuthorized with
  | True =>
    whilelistContractHolderMap[to] := approved;
    
    msg = {_tag : "onERC721StatusChanged";
      _recipient : to;
      _amount : Uint128 0;
      approved : approved};
    msgs = one_msg msg;
    send msgs;
  
    e = {_eventname: "setContractHolderStatus successful"};
    event e
  | False =>
    e = let raisedAt = "setContractHolder" in makeErrorEvent raisedAt code_not_authorized;
    event e
  end
end

transition createProduct(productId: Uint256, initialPrice: Uint128, initialInventoryQuantity: Uint128, supply: Uint128)
  
  isAuthorized = checkContractOwner owner _sender;
  match isAuthorized with
  | True =>
    copy_product <- productsMap[productId];

    match copy_product with
    | Some _ =>
      e = let raisedAt = "createProduct" in makeErrorEvent raisedAt code_product_exists;
      event e
    | None =>
      ivq = builtin lt supply initialInventoryQuantity;
      match ivq with
      | True =>
        e = let raisedAt = "createProduct" in makeErrorEvent raisedAt code_invalid_quantity;
        event e
      | False =>
        p = create_product productId initialPrice initialInventoryQuantity supply;
        productsMap[productId] := p;
        e = {_eventname: "createProduct successful"; id: productId};
        event e
      end
    end
    
  | False =>
    e = let raisedAt = "createProduct" in makeErrorEvent raisedAt code_not_authorized;
    event e
  end
end

transition purchaseProduct(productId: Uint256)
  copy_product <- productsMap[productId];

  match copy_product with
  | Some p =>
    match p with
    | Product id price available supply sold =>
      vp = builtin eq _amount price;
      match vp with
      | False =>
        e = let raisedAt = "purchaseProduct" in makeErrorEvent raisedAt code_purchase_error;
        event e
      | True =>
        po = purchase_one_unit_in_stock p;
        match po with
        | PurchaseInventoryFailed =>
          e = let raisedAt = "purchaseProduct" in makeErrorEvent raisedAt code_purchase_error;
          event e
        | PurchaseInventorySuccess np =>
          productsMap[productId] := np;
          x <- & BLOCKNUMBER;

          attributes = productId;
          dn = DinoSeed attributes x;

          n <- nonceSeed;
          one256 = Uint256 1;
          nid = builtin add n one256;
          nonceSeed := nid;

          dinoSeedMap[nid] := dn;

          accept;
         
          msg  = {_tag : "mint"; _recipient : _this_address; _amount : Uint128 0;
            to : _sender; tokenId : nid};
          
          msgs = one_msg msg;
          send msgs;

          e = {_eventname: "purchaseProduct successful"; id: nid};
          event e

        end
        
      end
    end
  | None =>
    e = let raisedAt = "purchaseProduct" in makeErrorEvent raisedAt code_product_not_exists;
    event e
  end
end

transition withdraw ()
  isAuthorized = checkContractOwner owner _sender;
  match isAuthorized with
  | True =>
    bal <- _balance;
    msg = {_tag : ""; _recipient : owner; _amount : bal; code : code_success};
    msgs = one_msg msg;
    e = { _eventname : "withdraw successful" };
    event e;
    send msgs
  | False =>
    msg = {_tag : ""; _recipient : _sender; _amount : Uint128 0; code : code_not_authorized};
    msgs = one_msg msg;
    send msgs
  end
end
